#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}

//============================================================================
// Name        : server.cpp
// Author      : Yuanqi Li
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C, Ansi-style
//============================================================================

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>   // definitions of a number of data types used in socket.h and netinet/in.h
#include <sys/socket.h>  // definitions of structures needed for sockets, e.g. sockaddr
#include <netinet/in.h>  // constants and structures needed for internet domain addresses, e.g. sockaddr_in
#include <stdlib.h>
#include <strings.h>
#include <sys/wait.h> /* for the waitpid() system call */
#include <signal.h> /* signal name macros, and the kill() prototype */
#include <string>
#include <cstring>

#include "utils.h"
using namespace std;

void dostuff(int); /* function prototype */
int sockfd;
struct sockaddr_in cli_addr;
socklen_t cli_len = sizeof(cli_addr);
unsigned int current_seqnum = 0;
unsigned int max_seqnum = 30720;

void init(int argc, char *argv[]) {
	int portno;
	struct sockaddr_in serv_addr;
	if (argc < 2) {
		printErrorAndExit("no port provided");
	}
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printErrorAndExit("cannot open socket");
	}
	bzero((char *) &serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	printf("*** Port number set to: %d\n", portno);
	if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
		printErrorAndExit("cannot bind");
	}
	printf("*** Waiting for request(s)...\n");
}

int main(int argc, char *argv[]) {
	init(argc, argv);
	char buffer[PACKET_SIZE];
	char* file_content;
	resetBuffer(buffer);
	while (1) {
//		if (recvfrom(sockfd, buffer, sizeof(buffer), 0,
//				(struct sockaddr*) &cli_addr, &cli_len) != -1) {
		if (true) {
//			string filename = getStringFromBuffer(buffer);
			string filename = "input";
			printf("*** File requested by client: %s\n", filename.c_str());

			if (!fileExists(filename)) {
				sendto(sockfd, FILE_NOT_FOUND_MSG,
						sizeof(char) * strlen(FILE_NOT_FOUND_MSG), 0,
						(struct sockaddr*) &cli_addr, sizeof(cli_addr));
				printf("*** %s\n", FILE_NOT_FOUND_MSG);
				printf("*** Continue to wait for further request(s)...\n");
			} else {
				printf("File exists\n");
				char *filepath = new char[filename.length() + 1];
				strcpy(filepath, filename.c_str());
				file_content = readFileToCharArray(filepath);
				long file_length = strlen(file_content);
				printf("file length: %d\n", file_length);
				int num_of_packets;
				int fraction = file_length % PACKET_DATA_SIZE;
				bool has_fraction = (fraction != 0);

				num_of_packets =
						has_fraction ?
								(file_length / PACKET_DATA_SIZE + 1) :
								(file_length / PACKET_DATA_SIZE);
				vector<Packet*> all_packets;
				printf("number of packets: %d\n", num_of_packets);
				for (int i = 0; i < num_of_packets; i++) {
					Packet* cur = new Packet;
					cur->setSeqnum(current_seqnum);
					if (current_seqnum + PACKET_SIZE > max_seqnum) {
						//wrap handling here
					}
					current_seqnum += PACKET_SIZE;
					cur->setFileSize(file_length);
					if (i == num_of_packets - 1 && has_fraction) {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
								fraction);
						printf("in if\n");
					} else {
						cur->setBuffer(file_content + i * PACKET_DATA_SIZE,
						PACKET_DATA_SIZE);
						printf("in else\n");

					}
					all_packets.push_back(cur);
				}

				char * output;
				output = (char *) calloc(file_length + 1, sizeof(char));
				printf("all_packets.size(): %d\n", all_packets.size());

				for (int i = 0; i < all_packets.size(); i++) {
					strcat(output, all_packets.at(i)->buffer);
					output[file_length] = '\0';
					FILE* f = fopen("output", "wb");
					if (f == NULL) {
						printErrorAndExit("ERROR with opening file");
					}

					fwrite(output, sizeof(char), file_length, f);

					fclose(f);
				}

			}

		}
		exit(0);

	} /* end of while */
	return 0; /* we never get here */
}

void dostuff(int sock) {
	printf("in do stuff\n");
}
